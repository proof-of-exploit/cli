use eth_types::Field;
use halo2_proofs::{circuit::*, plonk::*};
use zkevm_circuits::{
    super_circuit::{SuperCircuit, SuperCircuitConfig, SuperCircuitConfigArgs},
    util::{Challenges, SubCircuit, SubCircuitConfig},
    witness::Block,
};

#[derive(Clone)]
pub struct ExploitCircuitConfig<F: Field> {
    super_circuit_config: SuperCircuitConfig<F>,
}

pub struct ExploitCircuitConfigArgs {
    super_circuit_config_args: SuperCircuitConfigArgs,
}

impl<F: Field> SubCircuitConfig<F> for ExploitCircuitConfig<F> {
    type ConfigArgs = ExploitCircuitConfigArgs;

    fn new(
        meta: &mut ConstraintSystem<F>,
        Self::ConfigArgs {
            super_circuit_config_args,
        }: Self::ConfigArgs,
    ) -> Self {
        let super_circuit_config = SuperCircuitConfig::<F>::new(meta, super_circuit_config_args);
        ExploitCircuitConfig {
            super_circuit_config,
        }
    }
}

#[derive(Default)]
pub struct ExploitCircuit<
    F: Field,
    const MAX_TXS: usize,
    const MAX_CALLDATA: usize,
    const MOCK_RANDOMNESS: u64,
> {
    pub super_circuit: SuperCircuit<F, MAX_TXS, MAX_CALLDATA, MOCK_RANDOMNESS>,
}

impl<F: Field, const MAX_TXS: usize, const MAX_CALLDATA: usize, const MOCK_RANDOMNESS: u64>
    SubCircuit<F> for ExploitCircuit<F, MAX_TXS, MAX_CALLDATA, MOCK_RANDOMNESS>
{
    type Config = ExploitCircuitConfig<F>;

    fn new_from_block(block: &Block<F>) -> Self {
        let super_circuit = SuperCircuit::new_from_block(block);

        ExploitCircuit::<_, MAX_TXS, MAX_CALLDATA, MOCK_RANDOMNESS> { super_circuit }
    }

    /// Returns suitable inputs for the SuperCircuit.
    fn instance(&self) -> Vec<Vec<F>> {
        let mut instance = Vec::new();
        instance.extend_from_slice(&self.super_circuit.instance());

        instance
    }

    /// Return the minimum number of rows required to prove the block
    fn min_num_rows_block(block: &Block<F>) -> (usize, usize) {
        let super_circuit =
            SuperCircuit::<F, MAX_TXS, MAX_CALLDATA, MOCK_RANDOMNESS>::min_num_rows_block(block);

        let rows: Vec<(usize, usize)> = vec![super_circuit];
        let (rows_without_padding, rows_with_padding): (Vec<usize>, Vec<usize>) =
            rows.into_iter().unzip();
        (
            itertools::max(rows_without_padding).unwrap(),
            itertools::max(rows_with_padding).unwrap(),
        )
    }

    /// Make the assignments to the SuperCircuit
    fn synthesize_sub(
        &self,
        config: &Self::Config,
        challenges: &Challenges<Value<F>>,
        layouter: &mut impl Layouter<F>,
    ) -> Result<(), Error> {
        self.super_circuit
            .synthesize_sub(&config.super_circuit_config, challenges, layouter)?;
        Ok(())
    }
}

impl<F: Field, const MAX_TXS: usize, const MAX_CALLDATA: usize, const MOCK_RANDOMNESS: u64>
    Circuit<F> for ExploitCircuit<F, MAX_TXS, MAX_CALLDATA, MOCK_RANDOMNESS>
{
    type Config = ExploitCircuitConfig<F>;
    type FloorPlanner = SimpleFloorPlanner;

    fn without_witnesses(&self) -> Self {
        Self::default()
    }

    fn configure(meta: &mut ConstraintSystem<F>) -> Self::Config {
        Self::Config::new(
            meta,
            ExploitCircuitConfigArgs {
                super_circuit_config_args: SuperCircuitConfigArgs {
                    max_txs: MAX_TXS,
                    max_calldata: MAX_CALLDATA,
                    mock_randomness: MOCK_RANDOMNESS,
                },
            },
        )
    }

    fn synthesize(&self, config: Self::Config, layouter: impl Layouter<F>) -> Result<(), Error> {
        self.super_circuit
            .synthesize(config.super_circuit_config, layouter)
    }
}
