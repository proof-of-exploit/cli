use std::{
    fs::{self, create_dir_all, File},
    io::Write,
    path::{Path, PathBuf},
    process,
    str::FromStr,
};

use bus_mapping::circuit_input_builder::FixedCParams;
use clap::{arg, ArgMatches};
use eth_types::Fr;
use ethers::utils::hex;
use halo2_proofs::dev::MockProver;
use regex::Regex;
use serde_json::Value;
use zk_proof_of_evm_exploit::{
    real_prover::RealVerifier, types::zkevm_types::Bytes, BuilderClient, RealProver,
};
use zkevm_circuits::{
    super_circuit::SuperCircuit,
    util::{log2_ceil, SubCircuit},
};

const MAX_TXS: usize = 1;
const MAX_CALLDATA: usize = 256;
const RANDOMNESS: u64 = 0x100;

#[tokio::main]
async fn main() {
    let m = clap::Command::new("exploit")
        .version("v1.0.2")
        .about("Proof of Exploit")
        .subcommand(
            clap::Command::new("prove")
                .about("Generate proofs")
                .arg(arg!(--rpc <URL> "Enter ethereum archive node RPC url" ).required(true))
                .arg(arg!(--block <NUMBER> "Enter the fork block number" ).required(true))
                .arg(arg!(--challenge <CONTRACT> "Enter hex bytecode or file path" ).required(true))
                .arg(arg!(--exploit <CONTRACT> "Enter hex bytecode or file path" ).required(true))
                .arg(arg!(--tx <HEX> "Enter the tx" ).required(true))
                .arg(arg!(--dir <PATH> "Enter the dir for rw params" ).required(false))
                .arg(arg!(--max_rws <NUMBER>).default_value("1000"))
                .arg(arg!(--max_copy_rows <NUMBER>).default_value("1000"))
                .arg(arg!(--max_exp_steps <NUMBER>).default_value("1000"))
                .arg(arg!(--max_bytecode <NUMBER>).default_value("512"))
                .arg(arg!(--max_evm_rows <NUMBER>).default_value("1000"))
                .arg(arg!(--max_keccak_rows <NUMBER>).default_value("10000"))
                .arg(arg!(--mock "Use mock prover optionally")),
        )
        .subcommand(
            clap::Command::new("verify")
                .about("Verify proofs")
                .arg(arg!(--dir <PATH> "Enter the proof path for rw" ))
                .arg(arg!(--proof <PATH> "Enter the proof path for rw" ))
                .arg(arg!(--degree <DEGREE> "Enter the proof path for rw" ))
                .after_help("after verify help"),
        )
        // .subcommand(
        //     Command::new("publish")
        //         .about("Publish proof to IPFS")
        //         .arg(Arg::new("mock").long("mock").help("turns on mock mode"))
        //         .before_help("prove value")
        //         .arg(Arg::new("in_file")),
        // )
        .after_help(
            "Longer explanation to appear after the options when \
            displaying the help information from --help or -h",
        );
    // .subcommand(Command::new("hello").version("2.3"))
    let matches = m.get_matches();
    let sc = matches.subcommand_name();

    match sc {
        Some("prove") => {
            println!("matched prove");
            let prove_args = matches.subcommand_matches("prove").unwrap();

            let mock = prove_args.get_flag("mock");
            let rpc = prove_args.get_one::<String>("rpc").unwrap().clone();
            let block = parse(prove_args, "block");
            let challenge_bytecode: Bytes =
                if let Some(bytecode) = parse_optional(prove_args, "bytecode") {
                    bytecode
                } else {
                    let source_path: String = parse(prove_args, "challenge");
                    let mut cmd = process::Command::new("solc");
                    cmd.arg(source_path);
                    cmd.arg("--combined-json");
                    cmd.arg("bin");
                    let output = cmd.output().unwrap();
                    let stdout = String::from_utf8(output.stdout).unwrap();
                    println!("stdout: {}", stdout);

                    let solc_json_output: Value = serde_json::from_str(stdout.as_str()).unwrap();
                    let compiled_bytecode = 'cb: {
                        let regx = Regex::new(r"(?m)^([^:]+):(.+)$").unwrap();
                        for (key, val) in solc_json_output
                            .as_object()
                            .unwrap()
                            .get("contracts")
                            .unwrap()
                            .as_object()
                            .unwrap()
                        {
                            // println!("key: {}", key);
                            let contract_name = regx
                                .captures(key.as_str())
                                .unwrap()
                                .get(2)
                                .unwrap()
                                .as_str();
                            // println!("val: {:?}", val);
                            if contract_name == "Challenge" {
                                break 'cb val
                                    .as_object()
                                    .unwrap()
                                    .get("bin")
                                    .unwrap()
                                    .as_str()
                                    .unwrap();
                            }
                        }
                        panic!("Could not find a Challenge solidity contract");
                    };
                    Bytes::from_str(compiled_bytecode).unwrap()
                };

            let exploit_bytecode: Bytes = parse(prove_args, "exploit");

            let tx: Bytes = parse(prove_args, "tx");
            let dir: String = parse(prove_args, "dir");

            let max_rws = parse(prove_args, "max_rws");
            let max_copy_rows = parse(prove_args, "max_copy_rows");
            let max_exp_steps = parse(prove_args, "max_exp_steps");
            let max_bytecode = parse(prove_args, "max_bytecode");
            let max_evm_rows = parse(prove_args, "max_evm_rows");
            let max_keccak_rows = parse(prove_args, "max_keccak_rows");

            let builder = BuilderClient::from_config(
                FixedCParams {
                    max_rws,
                    max_txs: MAX_TXS,
                    max_calldata: MAX_CALLDATA,
                    max_copy_rows,
                    max_exp_steps,
                    max_bytecode,
                    max_evm_rows,
                    max_keccak_rows,
                },
                Some(rpc),
                Some(block),
            )
            .await
            .unwrap();

            let chain_id = builder.anvil.eth_chain_id().unwrap().unwrap();
            let block_number = builder.anvil.block_number().unwrap();
            println!("chain_id: {chain_id:?}, block_number: {block_number:?}");

            // updating challenge bytecode in local mainnet fork chain
            builder
                .anvil
                .set_code(
                    bus_mapping::POX_CHALLENGE_ADDRESS,
                    challenge_bytecode.clone(),
                )
                .await
                .unwrap();
            // updating exploit bytecode in local mainnet fork chain
            builder
                .anvil
                .set_code(bus_mapping::POX_EXPLOIT_ADDRESS, exploit_bytecode.clone())
                .await
                .unwrap();

            let hash = builder.anvil.send_raw_transaction(tx).await.unwrap();

            builder.anvil.wait_for_transaction(hash).await.unwrap();

            let rc = builder
                .anvil
                .transaction_receipt(hash)
                .await
                .unwrap()
                .unwrap();
            println!("transaction gas: {}", rc.gas_used.unwrap());

            println!("tx confirmed on anvil, hash: {}", hex::encode(hash));

            let tx = builder
                .anvil
                .transaction_by_hash(hash)
                .await
                .unwrap()
                .unwrap();

            let mut witness = builder
                .gen_witness(
                    tx.block_number.unwrap().as_usize(),
                    challenge_bytecode,
                    exploit_bytecode,
                )
                .await
                .unwrap();
            witness.randomness = Fr::from(RANDOMNESS);

            println!("witness generated");

            let (_, rows_needed) = SuperCircuit::<Fr>::min_num_rows_block(&witness);
            let circuit = SuperCircuit::<Fr>::new_from_block(&witness);
            let k = log2_ceil(64 + rows_needed);
            let instance = circuit.instance();
            // if args.print {
            //     println!("block witness: {witness:#?}");
            println!("instance: {instance:#?}");
            // }

            if mock {
                println!("running MockProver");
                let prover = MockProver::run(k, &circuit, instance).unwrap();
                println!("verifying constraints");
                prover.assert_satisfied_par();
                println!("success");
            } else {
                let mut dir_path = PathBuf::from_str(".").unwrap();
                if !dir.is_empty() {
                    dir_path = dir_path.join(dir)
                }
                create_dir_all(dir_path.clone()).unwrap();

                println!("running RealProver");
                let mut prover = RealProver::from(circuit, k);
                // let mut prover = RealProver::from(k, dir_path.clone());

                println!("generating proof");
                let (proof, _public_inputs) = prover.run(true).unwrap();

                let proof_path =
                    dir_path.join(Path::new(&format!("proof_{}_{}", k, hex::encode(hash))));
                println!("writing proof to {}", proof_path.display());
                let mut file = File::create(proof_path).unwrap();
                file.write_all(proof.as_slice()).unwrap();
                println!("success");

                // sanity check
                let verifier = prover.verifier();
                verifier.run(proof, _public_inputs).unwrap();
            }
        }
        Some("verify") => {
            println!("matched verify");
            let verify_args = matches.subcommand_matches("verify").unwrap();

            let degree = parse(verify_args, "degree");
            let dir: String = parse(verify_args, "dir");
            let proof_path: String = parse(verify_args, "proof");

            let mut dir_path = PathBuf::from_str(".").unwrap();
            if !dir.is_empty() {
                dir_path = dir_path.join(dir)
            }

            // let circuit = SuperCircuit::<Fr>::default();
            let verifier = RealVerifier::new(
                String::from_str("SuperCircuit").unwrap(),
                degree,
                dir_path,
                vec![2],
            );

            // let proof_file = File::open(proof_path).unwrap();

            let hardcoded_instance = [
                Fr::from_bytes(&[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 214, 202, 140, 103, 204, 234,
                    92, 235, 138, 246, 240, 168, 119, 195, 177, 16,
                ])
                .unwrap(),
                Fr::from_bytes(&[
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 214, 202, 140, 103, 204, 234,
                    92, 235, 138, 246, 240, 168, 119, 195, 177, 16,
                ])
                .unwrap(),
            ];
            let proof = fs::read(proof_path).unwrap();
            verifier
                .run(proof, vec![hardcoded_instance.to_vec(), vec![]])
                .unwrap();
        }
        _ => unimplemented!(),
    }

    // m.print_help();
}

fn parse<T: FromStr>(am: &ArgMatches, id: &str) -> T
where
    <T as std::str::FromStr>::Err: std::fmt::Debug,
{
    am.get_one::<String>(id)
        .unwrap_or_else(|| panic!("missing arg {}", id))
        .parse()
        .unwrap_or_else(|_| panic!("error parsing {}", id))
}

fn parse_optional<T: FromStr>(am: &ArgMatches, id: &str) -> Option<T>
where
    <T as std::str::FromStr>::Err: std::fmt::Debug,
{
    am.get_one::<String>(id).map(|val| val.parse().unwrap())

    // let raw_string_option = am.get_one::<String>(id);
    // if let Some(raw_string) = raw_string_option {
    //     Some(raw_string.parse().unwrap())
    // } else {
    //     None
    // }
}
