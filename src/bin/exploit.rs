use bus_mapping::circuit_input_builder::FixedCParams;
use clap::{arg, ArgMatches};
use eth_types::{Fr, U64};
use ethers::utils::{hex, parse_ether};
use halo2_proofs::dev::MockProver;
use std::{
    fs::create_dir_all,
    path::{Path, PathBuf},
    process,
    str::FromStr,
};
use zk_proof_of_evm_exploit::{
    env::Env,
    inputs_builder::PoxInputs,
    real_prover::{Proof, RealVerifier},
    types::zkevm_types::Bytes,
    utils::{compile_huff, compile_solidity},
    BuilderClient, RealProver,
};
use zkevm_circuits::{
    super_circuit::SuperCircuit,
    util::{log2_ceil, SubCircuit},
};

const MAX_TXS: usize = 1;
const MAX_CALLDATA: usize = 256;
const RANDOMNESS: u64 = 0x100;

#[tokio::main]
async fn main() {
    let env = Env::load();

    let mut m = clap::Command::new("exploit")
        .version("v1.0.2")
        .about("Proof of Exploit")
        .subcommand(
            clap::Command::new("test")
                .about("Test the exploit")
                .arg(arg!(--rpc <URL> "Enter ethereum archive node RPC url" ))
                .arg(arg!(--block <NUMBER> "Enter the fork block number" ))
                .arg(arg!(--challenge <CONTRACT> "Enter hex bytecode or file path" ))
                .arg(arg!(--exploit <CONTRACT> "Enter hex bytecode or file path" ))
                .arg(arg!(--"exploit-balance" <NUMBER> "Enter ether amount to fund 0xbada55 address" ))
                .arg(arg!(--tx <HEX> "Enter the tx" ))
                .arg(arg!(--dir <PATH> "Enter the dir for rw params" ))
                .arg(arg!(--max_rws <NUMBER>))
                .arg(arg!(--max_copy_rows <NUMBER>))
                .arg(arg!(--max_exp_steps <NUMBER>))
                .arg(arg!(--max_bytecode <NUMBER>))
                .arg(arg!(--max_evm_rows <NUMBER>))
                .arg(arg!(--max_keccak_rows <NUMBER>))
                .arg(arg!(--mock "Use mock prover optionally")),
        )
        .subcommand(
            clap::Command::new("prove")
                .about("Generate proofs")
                .arg(arg!(--rpc <URL> "Enter ethereum archive node RPC url" ))
                .arg(arg!(--block <NUMBER> "Enter the fork block number" ))
                .arg(arg!(--challenge <CONTRACT> "Enter hex bytecode or file path" ))
                .arg(arg!(--exploit <CONTRACT> "Enter hex bytecode or file path" ))
                .arg(arg!(--"exploit-balance" <NUMBER> "Enter ether amount to fund 0xbada55 address" ))
                .arg(arg!(--tx <HEX> "Enter the tx" ))
                .arg(arg!(--dir <PATH> "Enter the dir for rw params" ))
                .arg(arg!(--max_rws <NUMBER>))
                .arg(arg!(--max_copy_rows <NUMBER>))
                .arg(arg!(--max_exp_steps <NUMBER>))
                .arg(arg!(--max_bytecode <NUMBER>))
                .arg(arg!(--max_evm_rows <NUMBER>))
                .arg(arg!(--max_keccak_rows <NUMBER>))
                .arg(arg!(--mock "Use mock prover optionally")),
        )
        .subcommand(
            clap::Command::new("verify")
                .about("Verify proofs")
                .arg(arg!(--dir <PATH> "Enter the proof path for rw" ))
                .arg(arg!(--proof <PATH> "Enter the proof path for rw" ))
                .after_help("after verify help"),
        )
        // .subcommand(
        //     Command::new("publish")
        //         .about("Publish proof to IPFS")
        //         .arg(Arg::new("mock").long("mock").help("turns on mock mode"))
        //         .before_help("prove value")
        //         .arg(Arg::new("in_file")),
        // )
        .after_help(
            "Longer explanation to appear after the options when \
            displaying the help information from --help or -h",
        );
    // .subcommand(Command::new("hello").version("2.3"))
    let matches = m.clone().get_matches();
    let sc = matches.subcommand_name();

    match sc {
        Some("prove") | Some("test") => {
            let args_matches = matches
                .subcommand_matches("prove")
                .or(matches.subcommand_matches("test"))
                .unwrap();

            let mock = args_matches.get_flag("mock");
            let rpc = args_matches
                .get_one::<String>("rpc")
                .cloned()
                .or(env.eth_rpc_url);
            let block = parse_optional(args_matches, "block").or(env.fork_block_number);

            let challenge_bytecode = compile_solidity(
                parse_optional(args_matches, "challenge")
                    .or(env.challenge_path)
                    .unwrap_or("./src/Challenge.sol".to_string()),
                "Challenge",
            );

            let exploit_bytecode = compile_huff(
                parse_optional(args_matches, "exploit")
                    .or(env.exploit_path)
                    .unwrap_or("./src/Exploit.huff".to_string()),
            );

            let tx: Bytes = parse_optional(args_matches, "tx").unwrap_or(Bytes::from_str("0xf86c8084ee6b2800830249f094feedc0de000000000000000000000000000000008084b0d691fe8401546d72a01e8eb2b20f4b86774c885aaf14686a3c3f42843ce12b838e74cb5f87c5c4ca01a045dae624463186e4c7d4866fc72c1740e59de8b5d5295dc4e8c5393a4c4c02e1").unwrap());
            let dir: String = parse_optional(args_matches, "dir").unwrap_or("./srs".to_string());

            let max_rws =
                parse_optional(args_matches, "max_rws").unwrap_or(env.max_rws.unwrap_or(1000));
            let max_copy_rows = parse_optional(args_matches, "max_copy_rows")
                .unwrap_or(env.max_copy_rows.unwrap_or(1000));
            let max_exp_steps = parse_optional(args_matches, "max_exp_steps")
                .unwrap_or(env.max_exp_steps.unwrap_or(1000));
            let max_bytecode = parse_optional(args_matches, "max_bytecode")
                .unwrap_or(env.max_bytecode.unwrap_or(512));
            let max_evm_rows = parse_optional(args_matches, "max_evm_rows")
                .unwrap_or(env.max_evm_rows.unwrap_or(1000));
            let max_keccak_rows = parse_optional(args_matches, "max_keccak_rows")
                .unwrap_or(env.max_keccak_rows.unwrap_or(1000));

            let builder = BuilderClient::from_config(
                FixedCParams {
                    max_rws,
                    max_txs: MAX_TXS,
                    max_calldata: MAX_CALLDATA,
                    max_copy_rows,
                    max_exp_steps,
                    max_bytecode,
                    max_evm_rows,
                    max_keccak_rows,
                },
                rpc,
                block,
            )
            .await
            .unwrap();

            let chain_id = builder.anvil.eth_chain_id().unwrap().unwrap();
            let block_number = builder.anvil.block_number().unwrap();
            println!("anvil initialized - chain_id: {chain_id:?}, block_number: {block_number:?}");

            // updating challenge bytecode in local mainnet fork chain
            builder
                .anvil
                .set_code(
                    bus_mapping::POX_CHALLENGE_ADDRESS,
                    challenge_bytecode.clone(),
                )
                .await
                .unwrap();
            // updating exploit bytecode in local mainnet fork chain
            builder
                .anvil
                .set_code(bus_mapping::POX_EXPLOIT_ADDRESS, exploit_bytecode.clone())
                .await
                .unwrap();

            let exploit_balance = parse_ether(
                parse_optional(args_matches, "exploit-balance").unwrap_or("0".to_string()),
            )
            .unwrap();
            builder
                .anvil
                .set_balance(bus_mapping::POX_EXPLOIT_ADDRESS, exploit_balance)
                .await
                .unwrap();

            let hash = builder.anvil.send_raw_transaction(tx).await.unwrap();

            builder.anvil.wait_for_transaction(hash).await.unwrap();

            let rc = builder
                .anvil
                .transaction_receipt(hash)
                .await
                .unwrap()
                .unwrap();
            println!("transaction gas: {}", rc.gas_used.unwrap());
            // println!("transaction success: {}", rc.status.unwrap());
            if rc.status.unwrap() != U64::from(1) {
                // TODO make sure that storage is also updated and not just tx is successful
                // TODO make sure that storage update with reversion does not pass the lookup check
                // TODO also add a --traces option to print helpful info to debug this for user
                println!("error: exploit transaction is not successful.");
                process::exit(1);
            }

            if sc.unwrap() == "test" {
                println!("test passed");
                process::exit(0);
            }

            println!("tx confirmed on anvil, hash: {}", hex::encode(hash));

            let tx = builder
                .anvil
                .transaction_by_hash(hash)
                .await
                .unwrap()
                .unwrap();

            let mut witness = builder
                .gen_witness(
                    tx.block_number.unwrap().as_usize(),
                    PoxInputs {
                        challenge_bytecode,
                        exploit_bytecode,
                        exploit_balance,
                    },
                )
                .await
                .unwrap();
            witness.randomness = Fr::from(RANDOMNESS);

            println!("witness generated");

            let (_, rows_needed) = SuperCircuit::<Fr>::min_num_rows_block(&witness);
            let circuit = SuperCircuit::<Fr>::new_from_block(&witness);
            let k = log2_ceil(64 + rows_needed);
            let instance = circuit.instance();
            // if args.print {
            //     println!("block witness: {witness:#?}");
            println!("instance: {instance:#?}");
            // }

            if mock {
                println!("running MockProver");
                let prover = MockProver::run(k, &circuit, instance).unwrap();
                println!("verifying constraints");
                prover.assert_satisfied_par();
                println!("success");
            } else {
                let mut dir_path = PathBuf::from_str(".").unwrap();
                if !dir.is_empty() {
                    dir_path = dir_path.join(dir)
                }
                create_dir_all(dir_path.clone()).unwrap();

                println!("running RealProver");
                let mut prover = RealProver::from(circuit, k);

                println!("generating proof");
                let proof = prover.run(false).unwrap();
                let proof_path = dir_path.join(Path::new(&format!(
                    "proof_{}_{}.json",
                    k,
                    hex::encode(hash)
                )));
                println!("writing proof to {}", proof_path.display());
                proof.write_to_file(&proof_path).unwrap();
                println!("success");

                // sanity check
                let verifier = prover.verifier();
                verifier.verify(proof).unwrap();
            }
        }
        Some("verify") => {
            println!("matched verify");
            let verify_args = matches.subcommand_matches("verify").unwrap();

            let dir: String = parse(verify_args, "dir");
            let proof_path =
                PathBuf::from_str(parse::<String>(verify_args, "proof").as_str()).unwrap();

            let mut dir_path = PathBuf::from_str(".").unwrap();
            if !dir.is_empty() {
                dir_path = dir_path.join(dir)
            }

            let proof = Proof::read_from_file(&proof_path).unwrap();

            let verifier =
                RealVerifier::new("SuperCircuit".to_string(), proof.degree, dir_path, vec![2]);
            verifier.verify(proof).unwrap();
        }
        _ => m.print_help().unwrap(),
    }

    // m.print_help();
}

fn parse<T: FromStr>(am: &ArgMatches, id: &str) -> T
where
    <T as std::str::FromStr>::Err: std::fmt::Debug,
{
    am.get_one::<String>(id)
        .unwrap_or_else(|| panic!("missing arg {}", id))
        .parse()
        .unwrap_or_else(|_| panic!("error parsing {}", id))
}

fn parse_optional<T: FromStr>(am: &ArgMatches, id: &str) -> Option<T>
where
    <T as std::str::FromStr>::Err: std::fmt::Debug,
{
    am.get_one::<String>(id).map(|val| val.parse().unwrap())

    // let raw_string_option = am.get_one::<String>(id);
    // if let Some(raw_string) = raw_string_option {
    //     Some(raw_string.parse().unwrap())
    // } else {
    //     None
    // }
}
